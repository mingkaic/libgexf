# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.39
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Graph::LibGEXF;
use base qw(Exporter);
use base qw(DynaLoader);
package Graph::LibGEXFc;
bootstrap Graph::LibGEXF;
package Graph::LibGEXF;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Graph::LibGEXF;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Graph::LibGEXF;


############# Class : Graph::LibGEXF::ReadLockException ##############

package Graph::LibGEXF::ReadLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_ReadLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_ReadLockException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::ReadLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::WriteLockException ##############

package Graph::LibGEXF::WriteLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_WriteLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_WriteLockException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::WriteLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::MessageExceptionBuilder ##############

package Graph::LibGEXF::MessageExceptionBuilder;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*buildString = *Graph::LibGEXFc::MessageExceptionBuilder_buildString;
*abstractClass = *Graph::LibGEXFc::MessageExceptionBuilder_abstractClass;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_MessageExceptionBuilder($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::Graph ##############

package Graph::LibGEXF::Graph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_Graph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_Graph($self);
        delete $OWNER{$self};
    }
}

*addNode = *Graph::LibGEXFc::Graph_addNode;
*addEdge = *Graph::LibGEXFc::Graph_addEdge;
*removeNode = *Graph::LibGEXFc::Graph_removeNode;
*removeEdge = *Graph::LibGEXFc::Graph_removeEdge;
*removeInEdges = *Graph::LibGEXFc::Graph_removeInEdges;
*removeOutEdges = *Graph::LibGEXFc::Graph_removeOutEdges;
*containsNode = *Graph::LibGEXFc::Graph_containsNode;
*containsEdge = *Graph::LibGEXFc::Graph_containsEdge;
*getNodeCount = *Graph::LibGEXFc::Graph_getNodeCount;
*getEdgeCount = *Graph::LibGEXFc::Graph_getEdgeCount;
*getDegree = *Graph::LibGEXFc::Graph_getDegree;
*getNeighbors = *Graph::LibGEXFc::Graph_getNeighbors;
*clear = *Graph::LibGEXFc::Graph_clear;
*clearEdges = *Graph::LibGEXFc::Graph_clearEdges;
*readLock = *Graph::LibGEXFc::Graph_readLock;
*readUnlock = *Graph::LibGEXFc::Graph_readUnlock;
*writeLock = *Graph::LibGEXFc::Graph_writeLock;
*writeUnlock = *Graph::LibGEXFc::Graph_writeUnlock;
*isReadLock = *Graph::LibGEXFc::Graph_isReadLock;
*isWriteLock = *Graph::LibGEXFc::Graph_isWriteLock;
*isUnlock = *Graph::LibGEXFc::Graph_isUnlock;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::DirectedGraph ##############

package Graph::LibGEXF::DirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::Graph Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_DirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_DirectedGraph($self);
        delete $OWNER{$self};
    }
}

*getInEdges = *Graph::LibGEXFc::DirectedGraph_getInEdges;
*getOutEdges = *Graph::LibGEXFc::DirectedGraph_getOutEdges;
*getSuccessors = *Graph::LibGEXFc::DirectedGraph_getSuccessors;
*getPredecessors = *Graph::LibGEXFc::DirectedGraph_getPredecessors;
*getInDegree = *Graph::LibGEXFc::DirectedGraph_getInDegree;
*getOutDegree = *Graph::LibGEXFc::DirectedGraph_getOutDegree;
*isSuccessor = *Graph::LibGEXFc::DirectedGraph_isSuccessor;
*isPredecessor = *Graph::LibGEXFc::DirectedGraph_isPredecessor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::UndirectedGraph ##############

package Graph::LibGEXF::UndirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::Graph Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_UndirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_UndirectedGraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::GEXF ##############

package Graph::LibGEXF::GEXF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_GEXF(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_GEXF($self);
        delete $OWNER{$self};
    }
}

*getUndirectedGraph = *Graph::LibGEXFc::GEXF_getUndirectedGraph;
*getDirectedGraph = *Graph::LibGEXFc::GEXF_getDirectedGraph;
*swig__graph_get = *Graph::LibGEXFc::GEXF__graph_get;
*swig__graph_set = *Graph::LibGEXFc::GEXF__graph_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Graph::LibGEXF;

use version;
our $VERSION = '0.01';
1;
__END__

=encoding utf8

=head1 NAME

Graph::LibGEXF -

=head1 SYNOPSIS

  use Graph::LibGEXF;

=head1 DESCRIPTION

Graph::LibGEXF is

=head1 AUTHOR

sebastien heymann E<lt>sebastien.heymann@gephi.orgE<gt>

=head1 SEE ALSO

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
