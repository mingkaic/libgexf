# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.39
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package libgexf;
use base qw(Exporter);
use base qw(DynaLoader);
package libgexfc;
bootstrap libgexf;
package libgexf;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package libgexf;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package libgexf;


############# Class : libgexf::ReadLockException ##############

package libgexf::ReadLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_ReadLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_ReadLockException($self);
        delete $OWNER{$self};
    }
}

*what = *libgexfc::ReadLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::WriteLockException ##############

package libgexf::WriteLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_WriteLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_WriteLockException($self);
        delete $OWNER{$self};
    }
}

*what = *libgexfc::WriteLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::MessageExceptionBuilder ##############

package libgexf::MessageExceptionBuilder;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf );
%OWNER = ();
%ITERATORS = ();
*buildString = *libgexfc::MessageExceptionBuilder_buildString;
*abstractClass = *libgexfc::MessageExceptionBuilder_abstractClass;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_MessageExceptionBuilder($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::Graph ##############

package libgexf::Graph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_Graph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_Graph($self);
        delete $OWNER{$self};
    }
}

*addNode = *libgexfc::Graph_addNode;
*addEdge = *libgexfc::Graph_addEdge;
*removeNode = *libgexfc::Graph_removeNode;
*removeEdge = *libgexfc::Graph_removeEdge;
*removeInEdges = *libgexfc::Graph_removeInEdges;
*removeOutEdges = *libgexfc::Graph_removeOutEdges;
*containsNode = *libgexfc::Graph_containsNode;
*containsEdge = *libgexfc::Graph_containsEdge;
*getNodeCount = *libgexfc::Graph_getNodeCount;
*getEdgeCount = *libgexfc::Graph_getEdgeCount;
*getDegree = *libgexfc::Graph_getDegree;
*getNeighbors = *libgexfc::Graph_getNeighbors;
*clear = *libgexfc::Graph_clear;
*clearEdges = *libgexfc::Graph_clearEdges;
*readLock = *libgexfc::Graph_readLock;
*readUnlock = *libgexfc::Graph_readUnlock;
*writeLock = *libgexfc::Graph_writeLock;
*writeUnlock = *libgexfc::Graph_writeUnlock;
*isReadLock = *libgexfc::Graph_isReadLock;
*isWriteLock = *libgexfc::Graph_isWriteLock;
*isUnlock = *libgexfc::Graph_isUnlock;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::DirectedGraph ##############

package libgexf::DirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf::Graph libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_DirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_DirectedGraph($self);
        delete $OWNER{$self};
    }
}

*getInEdges = *libgexfc::DirectedGraph_getInEdges;
*getOutEdges = *libgexfc::DirectedGraph_getOutEdges;
*getSuccessors = *libgexfc::DirectedGraph_getSuccessors;
*getPredecessors = *libgexfc::DirectedGraph_getPredecessors;
*getInDegree = *libgexfc::DirectedGraph_getInDegree;
*getOutDegree = *libgexfc::DirectedGraph_getOutDegree;
*isSuccessor = *libgexfc::DirectedGraph_isSuccessor;
*isPredecessor = *libgexfc::DirectedGraph_isPredecessor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::UndirectedGraph ##############

package libgexf::UndirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf::Graph libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_UndirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_UndirectedGraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libgexf::GEXF ##############

package libgexf::GEXF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libgexf );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = libgexfc::new_GEXF(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libgexfc::delete_GEXF($self);
        delete $OWNER{$self};
    }
}

*getUndirectedGraph = *libgexfc::GEXF_getUndirectedGraph;
*getDirectedGraph = *libgexfc::GEXF_getDirectedGraph;
*swig__graph_get = *libgexfc::GEXF__graph_get;
*swig__graph_set = *libgexfc::GEXF__graph_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package libgexf;

1;
